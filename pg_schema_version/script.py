import os
import sys
import re
import logging
import argparse
from .utils import openfiles, bytes_hash, log

# NOTE this could be a postgres extension?
# FIXME skip begin/end which interact with plpgsql…
# TODO description can replace signature? added?
# TODO verbose mode with log.info
# TODO psv_cmd=help

APP_VERSION = r"""
--- show target app version if available
SELECT MAX(version) AS psv_version
  FROM PsvAppStatus
  WHERE app = :'psv_app'
  \gset
\if :{{?psv_version}}
  \echo # psv :psv_app version: :psv_version
  \unset psv_version
\else
  \echo # psv :psv_app is not registered
\endif
"""

SCRIPT_HEADER = r"""--
-- AUTOMATICALLY GENERATED PSQL SCRIPT FOR APP {app}
--
-- This psql script has been generated by "pg-schema-version".
-- Edit with care, or possibly do not edit…
--
-- See: https://github.com/zx80/pg-schema-version
--

-- any error will stop the script immediately
\set ON_ERROR_STOP 1

-- check postgres server version
SELECT :SERVER_VERSION_NUM < 100000 AS psv_pg_ko \gset
\if :psv_pg_ko
  \warn # ERROR psv requires postgres version 10 or above
  \quit
\endif
\unset psv_pg_ko

-- command to execute
\if :{{?psv_cmd}}
  \echo # psv command is :psv_cmd
\else
  -- default command is to run the script (no init nor register)
  \set psv_cmd run
  \echo # psv command set to :psv_cmd, set with -v psv_cmd=…
\endif

-- application name
\set psv_app {app}

-- set expected phases
SELECT
  -- whether to initialize the infra if needed
  :'psv_cmd' IN ('create', 'init')            AS psv_do_init,
  -- whether to register the application if needed
  :'psv_cmd' IN ('create', 'register')        AS psv_do_register,
  -- whether to show all application status
  TRUE                                        AS psv_do_status,
  -- whether to run schema create steps
  :'psv_cmd' IN ('create', 'run')             AS psv_do_steps,
  -- whether to remove the infrastructure
  :'psv_cmd' IN ('remove')                    AS psv_do_remove,
  -- check command validity
  :'psv_cmd' NOT IN ('init', 'register', 'run', 'create', 'status', 'remove') AS psv_bad_cmd
  \gset

-- check that command is valid
\if :psv_bad_cmd
  \warn # ERROR psv unexpected command :psv_cmd, expecting: init register run create status remove
  \quit
\endif
\unset psv_bad_cmd

-- set psv_dry
\if :{{?psv_wet}}
  \echo # psv wet :psv_cmd for :psv_app
  \set psv_dry 0
  \unset psv_wet
\else
  \echo # psv dry :psv_cmd for :psv_app, enable with -v psv_wet=1
  \set psv_dry 1
\endif

--
-- INIT create psv pristine infra if needed
--
SELECT COUNT(*) = 0 AS psv_no_infra
  FROM pg_catalog.pg_tables
  WHERE schemaname = '{schema}'
    AND tablename = 'psv_app_status'
  \gset

\if :psv_do_init
  \if :psv_no_infra
    \if :psv_dry
      -- output a precise message before quitting
      \if :psv_do_steps
         \if :psv_do_register
           \echo # psv will create infra, register :psv_app and execute all steps
         \else
           -- UNREACHABLE
           \warn # INTERNAL ERROR should not init and run without registering
           \quit
         \endif
      \else
         \if :psv_do_register
           \echo # psv will create infra and register :psv_app
         \else
           \echo # psv will create infra
         \endif
      \endif
      -- always quit without infra anyway
      \quit
    \else
      -- wet run, do the job!
      \echo # psv creating infra

BEGIN;

-- create psv application status table
CREATE TABLE {schema}.psv_app_status(
  id SERIAL PRIMARY KEY,
  app TEXT NOT NULL DEFAULT 'psv',
  version INTEGER NOT NULL DEFAULT 0,
  signature TEXT DEFAULT NULL,
  created TIMESTAMP NOT NULL DEFAULT NOW(),
  UNIQUE(app, version),
  UNIQUE(signature),
  CHECK (version = 0 AND signature IS NULL OR version > 0 AND signature IS NOT NULL)
);

-- register itself
INSERT INTO PUBLIC.psv_app_status DEFAULT VALUES;

COMMIT;

    \endif
  \else
    -- infra already exists
    \if :psv_dry
      \echo # psv will skip infra initialization
    \else
      \echo # psv skipping psv infra initialization
    \endif
  \endif
\else
  -- do not initialize
  \if :psv_no_infra
    \if :psv_dry
      \echo # psv will skip needed infra initialization… consider commands init or create
    \else
      \warn # psv skipping needed psv infra initialization… consider commands init or create
    \endif
  -- else there is an infra and we do not to init
  \endif
\endif

--
-- STATUS
--

\if :psv_do_status

  -- quit if infra is not available
  \if :psv_no_infra
    \if :psv_do_init
      -- ok, will have been initialized
      \if :psv_dry
        \echo # psv will show all application status
        -- nothing else to do
        \quit
      -- else proceed below
      \endif
    \else
      -- no infra and not initialized
      \warn # ERROR cannot show status without psv infra, consider commands init or create
      \quit
    \endif
  \endif

  -- show all app versions
  \echo # psv all applications status

  SELECT app, MAX(version) AS version
    FROM psv_app_status
    GROUP BY 1
    ORDER BY 1;

\endif

--
-- REMOVE psv infra
-- this is placed after STATUS so that the current status is shown
--
\if :psv_do_remove
  \if :psv_dry
    \echo # psv will drop its infra if it exists
  \else
    DROP TABLE IF EXISTS psv_app_status;
  \endif
  -- nothing else to do
  \quit
\endif

--
-- setup dry run, changes are operated on a temporary copy
--
\if :psv_dry
  -- copy
  CREATE TEMPORARY TABLE PsvAppStatus
    AS SELECT * FROM {schema}.psv_app_status;
\else
  -- reference
  CREATE TEMPORARY VIEW PsvAppStatus
    AS SELECT * FROM {schema}.psv_app_status;
\endif

-- self check for possible future upgrades
SELECT MAX(version) <> 0 AS psv_not_v0
  FROM PsvAppStatus
  WHERE app = 'psv'
  \gset

\if :psv_not_v0
  \warn # ERROR unexpected psv version
  \quit
\endif

-- check that the application is known
SELECT COUNT(*) = 0 AS psv_app_ko
  FROM PsvAppStatus
  WHERE app = :'psv_app'
  \gset

\if :psv_app_ko
  \if :psv_do_register
    \if :psv_dry
      \echo # psv will register :psv_app
    \else
      \echo # psv registering :psv_app
    \endif
    -- actually register, possibly on the copy for the dry run
    INSERT INTO PsvAppStatus(app) VALUES (:'psv_app');
  \else
    -- not registered and will not register…
    \if :psv_do_steps
      \warn # ERROR :psv_app registration needed
      \quit
    -- else it will not be needed
    \endif
  \endif
\else
  \if :psv_do_register
    \if :psv_dry
      \echo # psv will skip :psv_app registration
    \else
      \echo # psv skipping :psv_app registration
    \endif
  \endif
\endif

-- consider each step
\if :psv_do_steps
  \if :psv_dry
    \echo # psv will consider applying all steps
  \else
    \echo # psv considering all steps
  \endif

""" + APP_VERSION

FILE_HEADER = r"""
--
-- File {file}
--
-- check whether version is needed
\set psv_version {version}
\set psv_signature {signature}

-- app schema upgrade already applied
SELECT COUNT(*) = 0 AS psv_version_needed
  FROM PsvAppStatus
  WHERE app = :'psv_app'
    AND version = :psv_version
  \gset

-- app schema upgrade already applied with another script
SELECT COUNT(*) = 0 AS psv_version_inconsistent
  FROM PsvAppStatus
  WHERE app = :'psv_app'
    AND version = :psv_version
    AND signature = :'psv_signature'
  \gset

-- this script was used somewhere already
SELECT COUNT(*) > 0 AS psv_signature_used
  FROM PsvAppStatus
  WHERE app = :'psv_app'
    AND signature = :'psv_signature'
  \gset

\if :psv_version_needed
  \if :psv_signature_used
    \warn # ERROR :psv_app :psv_version script already applied
    \quit
  \endif
  \if :psv_dry
    \echo # psv will apply :psv_app :psv_version
    -- upgrade application new version for dry run
    INSERT INTO PsvAppStatus(app, version, signature)
      VALUES (:'psv_app', :psv_version, :'psv_signature');
  \else
    \echo # applying :psv_app :psv_version

BEGIN;
"""

FILE_FOOTER = r"""
  -- upgrade application new version
  INSERT INTO PsvAppStatus(app, version, signature)
    VALUES (:'psv_app', :psv_version, :'psv_signature');

COMMIT;

  \endif
\else
  -- step not needed
  \if :psv_version_inconsistent
    \warn # ERROR :psv_app :psv_version inconsistent signature
    \quit
  \endif
  \if :psv_dry
    \echo # psv will skip :psv_app :psv_version
  \else
    \echo # psv skipping :psv_app :psv_version
  \endif
\endif

\unset psv_version
\unset psv_signature
"""

SCRIPT_FOOTER = APP_VERSION + r"""
\else
  -- do not apply steps
  \if :psv_dry
    \echo # psv will skip all schema creation steps for command :psv_cmd
  \else
    \echo # psv skipping all schema creation steps for command :psv_cmd
  \endif
\endif

-- final output
\if :psv_dry
  DROP TABLE PsvAppStatus;
  \echo # psv dry :psv_cmd for :psv_app done
\else
  DROP VIEW PsvAppStatus;
  \echo # psv wet :psv_cmd for :psv_app done
\endif

-- end of {app} psv script
"""

def gen_psql_script(args):
    """Generate an idempotent psql script."""

    def output(s: str):
        print(s, file=args.out, end="")

    output(SCRIPT_HEADER.format(app=args.app, schema=args.schema))

    version = 0
    for fn, fh in openfiles(args.sql):
        version += 1
        script = fh.read()
        # sanity checks
        if re.search(r"^\s*\\", script, re.M):
            if args.trust_scripts:
                log.warning(f"script {fn} seems to contain a backslash command")
            else:
                log.error(f"script {fn} contains a backslash command")
                return 1
        if re.search(r"^\s*(commit|rollback|savepoint)\b", script, re.I|re.M):
            if args.trust_scripts:
                log.warning(f"script {fn} seems to contain a transaction command")
            else:
                log.error(f"script {fn} contains a transaction command")
                return 2
        data = script.encode(args.encoding)
        signature = bytes_hash(args.hash, data)
        # output psql code
        output(FILE_HEADER.format(file=fn, version=version, signature=signature))
        output(script)
        output(FILE_FOOTER)

    output(SCRIPT_FOOTER.format(app=args.app, schema=args.schema))

    return 0

def psv():

    logging.basicConfig()

    ap = argparse.ArgumentParser(
            prog="pg-schema-version",
            description="Generate an idempotent psql script for Postgres schema versioning.",
            epilog="All software have bugs…")
    ap.add_argument("-d", "--debug", action="store_true",
                    help="debug mode")
    ap.add_argument("-a", "--app", type=str, default="app",
                    help="application name, default is app")
    ap.add_argument("-s", "--schema", type=str, default="public",
                    help="schema for psv infra, default is public")
    ap.add_argument("-e", "--encoding", type=str, default="UTF-8",
                    help="sql file encoding, default is UTF-8")
    ap.add_argument("-H", "--hash", type=str, default="sha3_256",
                    help="hashlib algorithm for step signature, default is SHA3-256")
    ap.add_argument("-o", "--out", type=str, default=sys.stdout,
                    help="output script, default on stdout")
    ap.add_argument("-T", "--trust-scripts", action="store_true",
                    help="blindly trust provided scripts")
    ap.add_argument("sql", nargs="*",
                    help="sql data definition files")
    args = ap.parse_args()

    if args.debug:
        log.setLevel(logging.DEBUG)

    if isinstance(args.out, str):
        if os.path.exists(args.out):
            log.error(f"psv will not overwrite output file {args.out}, remove it first")
            return 2
        args.out = open(args.out, "w")

    return gen_psql_script(args)
