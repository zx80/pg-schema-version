import logging
import argparse
import sys
from .utils import openfiles, bytes_hash, log

# NOTE this could be a postgres extension?
# TODO do not rely on search path?
# TODO warn about explicit transactions
# TODO warn about backslash commands

SCRIPT_HEADER = r"""--
-- DO NOT EDIT
--
-- This psql script has been generated by "psv".
-- See: https://github.com/zx80/pg-schema-version
--

\set STOP_ON_ERROR 1
\set psv_app {app}

-- check postgres server version
SELECT :SERVER_VERSION_NUM < 100000 AS psv_pg_ko \gset
\if :psv_pg_ko
  \echo # psv requires pg version 10 or above
  \! kill $PPID
  \quit
\endif

-- set psv_dry_run
\if :{{?psv_wet_run}}
  \echo # psv wet run for :psv_app
  \set psv_dry_run 0
\else
  \echo # psv dry run for :psv_app, enable with -v psv_wet_run=1
  \set psv_dry_run 1
\endif

--
-- create psv infrastructure if necessary
--

SELECT COUNT(*) = 0 AS psv_no_infra
  FROM pg_tables
  WHERE tablename = 'psv_app_status' \gset

\if :psv_no_infra
  \if :psv_dry_run
    \echo # psv will create infrastructure and execute all commands
    \! kill $PPID
    \quit
  \else
    \echo # creating PSV infrastructure

BEGIN;
CREATE TABLE PUBLIC.psv_app_status(
  id SERIAL PRIMARY KEY,
  app TEXT NOT NULL DEFAULT :'psv_app',
  version INTEGER NOT NULL DEFAULT 0,
  signature TEXT DEFAULT NULL,
  created TIMESTAMP NOT NULL DEFAULT NOW(),
  UNIQUE(app, version),
  UNIQUE(signature)
);
INSERT INTO PUBLIC.psv_app_status DEFAULT VALUES;
COMMIT;

  \endif
\endif

-- dry run changes are operated on a temporary copy
\if :psv_dry_run
  -- copy
  CREATE TEMPORARY TABLE PsvAppStatus
    AS SELECT * FROM PUBLIC.psv_app_status;
\else
  -- reference
  CREATE TEMPORARY VIEW PsvAppStatus
    AS SELECT * FROM PUBLIC.psv_app_status;
\endif

-- check that the application is known
SELECT COUNT(*) = 0 AS psv_app_ko FROM PsvAppStatus WHERE app = :'psv_app' \gset
\if :psv_app_ko
  \if :{{?psv_force_app}}
    INSERT INTO PsvAppStatus(app) VALUES (:'psv_app');
  \else
    \echo # ERROR application :psv_app is unknown, force addition with -v psv_force_app=1
    \! kill $PPID
    \quit
  \endif
\endif
"""

FILE_HEADER = r"""
--
-- File {file}
--
-- check whether version is needed
\set psv_version {version}
\set psv_hash {hash}

SELECT COUNT(*) = 0 AS psv_version_needed
  FROM PsvAppStatus
  WHERE app = :'psv_app'
    AND version = :psv_version
  \gset

SELECT COUNT(*) = 0 AS psv_version_consistent
  FROM PsvAppStatus
  WHERE app = :'psv_app'
    AND version = :psv_version
    AND signature = :'psv_hash'
  \gset

SELECT COUNT(*) > 0 AS psv_hash_used
  FROM PsvAppStatus
  WHERE app = :'psv_app'
    AND signature = :'psv_hash'
  \gset

\if :psv_version_needed
  \if :psv_hash_used
    \echo # ERROR :psv_app version :psv_version hash already used
    \! kill $PPID
    \quit
  \endif
  \if :psv_dry_run
    \echo # psv will apply :psv_app version :psv_version
  \else
    \echo # applying :psv_app version :psv_version
BEGIN;
  INSERT INTO PsvAppStatus(app, version, signature)
    VALUES (:'psv_app', :psv_version, :'psv_hash');
"""

FILE_FOOTER = r"""
COMMIT;
  \endif
\else
  \if :psv_version_consistent
    -- ok!
  \else
    \echo # ERROR :psv_app version :psv_version inconsistent hash
    \! kill $PPID
    \quit
  \endif
  \if :psv_dry_run
    \echo # psv will skip :psv_app version :psv_version
  \else
    \echo # skipping :psv_app version :psv_version
  \endif
\endif
"""

SCRIPT_FOOTER = r"""
\if :psv_dry_run
  \echo # dry run done
  DROP TABLE PsvAppStatus;
\else
  SELECT MAX(version) AS psv_version
    FROM PsvAppStatus
    WHERE app = :'psv_app'
    \gset
  \echo # :psv_app version: :psv_version 
\endif
"""

def gen_psql_script(args):
    """Generate an idempotent psql script."""

    if args.debug:
        log.setLevel(logging.DEBUG)

    print(SCRIPT_HEADER.format(app=args.app))
    version = 0
    for fn, fh in openfiles(args.sql): 
        version += 1
        script = fh.read()
        print(FILE_HEADER.format(file=fn, version=version, hash=bytes_hash(args.hash, script)))
        print(script)
        print(FILE_FOOTER)
    print(SCRIPT_FOOTER)

    return 0

def psv():

    logging.basicConfig()

    ap = argparse.ArgumentParser()
    ap.add_argument("-d", "--debug", help="debug mode", action="store_true")
    ap.add_argument("-a", "--app", help="application name", type=str, default="app")
    ap.add_argument("--hash", help="hash algorithm", type=str, default="sha3_256")
    ap.add_argument("sql", help="sql data definition files, defaults to stdin", nargs="*")
    args = ap.parse_args()

    return gen_psql_script(args)
